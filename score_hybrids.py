'''Script to compute hybrid scores for intermediate sequences.

For each intermediate sequence generated by the pathway search, this script
computes its sequence identity to the start and end sequences in the
FULL_CONTEXT_FILE alignment.
'''

import os
import sys
import torch
from pysam import FastaFile
from tmtools import tm_align
from tmtools.io import get_structure, get_residue_data
import matplotlib.pyplot as plt


# Ensure we can import from the project root when running as a script
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
if ROOT_DIR not in sys.path:
    sys.path.insert(0, ROOT_DIR)

from config.settings import (  # type: ignore  # noqa: E402
    FULL_CONTEXT_FILE,
    START_SEQ_NAME,
    END_SEQ_NAME,
    GENERATOR_OUTPUT_PATH,
    RANDOM_SEED,
)

from transformers import AutoTokenizer, EsmForProteinFolding
torch.backends.cuda.matmul.allow_tf32 = True
from transformers.models.esm.openfold_utils.protein import to_pdb, Protein as OFProtein
from transformers.models.esm.openfold_utils.feats import atom14_to_atom37

#esmfold model
esmfold_tokenizer = AutoTokenizer.from_pretrained("facebook/esmfold_v1")
esmfold_model = EsmForProteinFolding.from_pretrained("facebook/esmfold_v1", low_cpu_mem_usage=True)
esmfold_model = esmfold_model.cuda().eval()

def convert_outputs_to_pdb(outputs):
    final_atom_positions = atom14_to_atom37(outputs["positions"][-1], outputs)
    outputs = {k: v.to("cpu").numpy() for k, v in outputs.items()}
    final_atom_positions = final_atom_positions.cpu().numpy()
    final_atom_mask = outputs["atom37_atom_exists"]
    pdbs = []
    for i in range(outputs["aatype"].shape[0]):
        aa = outputs["aatype"][i]
        pred_pos = final_atom_positions[i]
        mask = final_atom_mask[i]
        resid = outputs["residue_index"][i] + 1
        pred = OFProtein(
            aatype=aa,
            atom_positions=pred_pos,
            atom_mask=mask,
            residue_index=resid,
            b_factors=outputs["plddt"][i],
            chain_index=outputs["chain_index"][i] if "chain_index" in outputs else None,
        )
        pdbs.append(to_pdb(pred))
    return pdbs

def get_esmfold_structure(protein_sequence):
    tokenized_input = esmfold_tokenizer([protein_sequence], return_tensors="pt", add_special_tokens=False)['input_ids']
    tokenized_input = tokenized_input.cuda()
    with torch.no_grad():
        output = esmfold_model(tokenized_input)
    pdb_str = convert_outputs_to_pdb(output)[0]
    return pdb_str

''' predict structure using esmfold and then use pdb file to get mpnn score '''
def struct_prediction(protein_sequence, protein_sequence_name, save_path):

    # check if pdbs directory exists
    if not os.path.exists(save_path + '/pdbs'):
        os.makedirs(save_path + '/pdbs')

    protein_sequence_name_wo_dots = protein_sequence_name.replace(".", "_")
    pdb_structure_esmfold_file = f"{save_path}/pdbs/{protein_sequence_name_wo_dots}.pdb"

    # check if save path exists
    if not os.path.exists(pdb_structure_esmfold_file):
        # predict the pdb structure from esmfold
        with torch.no_grad():
            protein_sequence_wo_gaps = protein_sequence.replace("-", "")
            pdb_str = get_esmfold_structure(protein_sequence_wo_gaps)

        # save the pdb structure
        with open(pdb_structure_esmfold_file, 'w') as f:
            f.write(pdb_str)
    print(f"Structure predicted for {protein_sequence_name}")
    return pdb_structure_esmfold_file


def sequence_identity(seq_a: str, seq_b: str) -> float:
    """Compute simple sequence identity between two aligned sequences."""
    if not seq_a or not seq_b:
        return 0.0

    length = min(len(seq_a), len(seq_b))
    if length == 0:
        return 0.0

    matches = sum(c1 == c2 for c1, c2 in zip(seq_a[:length], seq_b[:length]))
    return matches / float(length)

def get_tmscore(query_pdb_file, reference_pdb_file):

    query_pdb = get_structure(query_pdb_file)
    reference_pdb = get_structure(reference_pdb_file)
            
    chain1 = next(query_pdb.get_chains())
    query_coords, query_seq_wo_gap = get_residue_data(chain1)

    chain2 = next(reference_pdb.get_chains())
    reference_coords, reference_seq_wo_gap = get_residue_data(chain2)

    res_wrt_protein1 = tm_align(reference_coords, query_coords, reference_seq_wo_gap, query_seq_wo_gap)
    
    str_similarity = res_wrt_protein1.tm_norm_chain1

    return str_similarity


def calc_hybrid_score() -> dict:
    # Load start and end sequences from the full MSA context
    print(f"Starting hybrid score calculation.")
    global_fasta = FastaFile(FULL_CONTEXT_FILE)
    starting_aln_sequence = global_fasta.fetch(START_SEQ_NAME)
    ending_aln_sequence = global_fasta.fetch(END_SEQ_NAME)

    # structure prediction for start and end sequence
    start_seq_pdb_file = os.path.join(GENERATOR_OUTPUT_PATH, f"pdbs/{START_SEQ_NAME}.pdb")
    end_seq_pdb_file = os.path.join(GENERATOR_OUTPUT_PATH, f"pdbs/{END_SEQ_NAME}.pdb")

    if not os.path.exists(start_seq_pdb_file):
        start_seq_pdb_file = struct_prediction(starting_aln_sequence, START_SEQ_NAME, GENERATOR_OUTPUT_PATH)
    if not os.path.exists(end_seq_pdb_file):
        end_seq_pdb_file = struct_prediction(ending_aln_sequence, END_SEQ_NAME, GENERATOR_OUTPUT_PATH)

    seq_similarity_bt_start_end = sequence_identity(starting_aln_sequence, ending_aln_sequence)
    str_similarity_bt_start_end = get_tmscore(start_seq_pdb_file, end_seq_pdb_file)

    # weight for calculating hybrid score
    str_wt = (1 - str_similarity_bt_start_end) / ((1 - seq_similarity_bt_start_end) + (1 - str_similarity_bt_start_end))
    seq_wt = 1 - str_wt
    print(f"Sequence weight: {seq_wt} and Structure weight: {str_wt} for calculating hybrid score.")

    # Path to intermediate sequences produced by generate_pathway.py
    intermediate_sequences_file = os.path.join(
        GENERATOR_OUTPUT_PATH,
        f"beam_evol_msat_intermediate_seqs_{RANDOM_SEED}.fasta",
    )

    if not os.path.exists(intermediate_sequences_file):
        print(f"Intermediate FASTA not found: {intermediate_sequences_file}")
        return

    intermediates_fa = FastaFile(intermediate_sequences_file)
    intermediate_sequence_dict: dict[str, dict] = {}

    for int_seq_name in intermediates_fa.references:
        int_aln_sequence = intermediates_fa.fetch(int_seq_name)
        source_similarity = sequence_identity(int_aln_sequence, starting_aln_sequence)
        target_similarity = sequence_identity(int_aln_sequence, ending_aln_sequence)

        # predict structure
        int_seq_pdb_file = os.path.join(GENERATOR_OUTPUT_PATH, f"pdbs/{int_seq_name}.pdb")
        if not os.path.exists(int_seq_pdb_file):
            int_seq_pdb_file = struct_prediction(int_aln_sequence, int_seq_name, GENERATOR_OUTPUT_PATH)

        # get TM-score to start and end structures
        tmscore_int_start = get_tmscore(int_seq_pdb_file, start_seq_pdb_file)
        tmscore_int_end = get_tmscore(int_seq_pdb_file, end_seq_pdb_file)

        # get metrics for plotting and hybrid score
        min_seq_similarity = min(source_similarity, target_similarity)
        min_str_similarity = min(tmscore_int_start, tmscore_int_end)

        wt_hybrid_score = seq_wt * min_seq_similarity + str_wt * min_str_similarity

        intermediate_sequence_dict[int_seq_name] = {
            "source_seq_similarity": source_similarity,
            "target_seq_similarity": target_similarity,
            "source_str_similarity": tmscore_int_start,
            "target_str_similarity": tmscore_int_end,
            "min_seq_similarity": min_seq_similarity,
            "min_str_similarity": min_str_similarity,
            "seq_wt": seq_wt,
            "str_wt": str_wt,
            "hybrid_score": wt_hybrid_score,
        }
    print(f"Hybrid score calculation completed.")
    return intermediate_sequence_dict


def plot_hybrid_score() -> None:
    """Scatter: min_seq_similarity (x) vs min_str_similarity (y), colored by hybrid_score."""
    scores = calc_hybrid_score()
    print(f"Plotting hybrid score scatter plot.")

    x_vals = []
    y_vals = []
    c_vals = []

    # Save scores to CSV for downstream analysis
    csv_path = os.path.join(
        GENERATOR_OUTPUT_PATH,
        f"hybrid_scores_{RANDOM_SEED}.csv",
    )
    with open(csv_path, "w") as f:
        f.write(
            "name,min_seq_similarity,min_str_similarity,hybrid_score,"
            "source_seq_similarity,target_seq_similarity,"
            "source_str_similarity,target_str_similarity,seq_wt,str_wt\n"
        )
        for name, s in scores.items():
            f.write(
                f"{name},"
                f"{s['min_seq_similarity']:.6f},"
                f"{s['min_str_similarity']:.6f},"
                f"{s['hybrid_score']:.6f},"
                f"{s['source_seq_similarity']:.6f},"
                f"{s['target_seq_similarity']:.6f},"
                f"{s['source_str_similarity']:.6f},"
                f"{s['target_str_similarity']:.6f},"
                f"{s['seq_wt']:.6f},"
                f"{s['str_wt']:.6f}\n"
            )
    print(f"Saved hybrid scores to {csv_path}")

    for name, s in scores.items():  # noqa: B007
        x_vals.append(s["min_seq_similarity"])
        y_vals.append(s["min_str_similarity"])
        c_vals.append(s["hybrid_score"])

    if not x_vals:
        print("No intermediate scores to plot.")
        return

    plt.figure(figsize=(6, 5))
    sc = plt.scatter(x_vals, y_vals, c=c_vals, cmap="viridis", edgecolors="k", s=40)
    plt.xlabel("Min sequence similarity (to start/end)")
    plt.ylabel("Min structural similarity (TM-score to start/end)")
    plt.title("Hybrid score landscape")
    cbar = plt.colorbar(sc)
    cbar.set_label("Hybrid score")
    plt.tight_layout()

    out_path = os.path.join(
        GENERATOR_OUTPUT_PATH,
        f"hybrid_score_scatter_{RANDOM_SEED}.png",
    )
    plt.savefig(out_path, dpi=300)
    plt.close()
    print(f"Saved hybrid score scatter plot to {out_path}")


if __name__ == "__main__":
    plot_hybrid_score()
